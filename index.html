<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reddit Analyzer - 3-Step Interactive Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.95em;
        }

        .input-section {
            padding: 30px;
            border-bottom: 2px solid #eee;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-group input {
            flex: 1;
            padding: 12px;
            border: 2px solid #eee;
            border-radius: 8px;
            font-size: 16px;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .loading {
            text-align: center;
            padding: 60px;
            display: none;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .step-container {
            display: none;
            padding: 30px;
            border-bottom: 2px solid #eee;
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .step-number {
            background: #667eea;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
        }

        .step-title {
            font-size: 1.5em;
            color: #1a202c;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9em;
            color: #718096;
        }

        .comment-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .comment-card {
            background: #f9fafb;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }

        .comment-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #718096;
        }

        .comment-author {
            font-weight: 600;
            color: #667eea;
        }

        .comment-score {
            color: #38a169;
        }

        .comment-body {
            color: #2d3748;
            white-space: pre-wrap;
        }

        .recommendations-grid {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .recommendation-card {
            background: #f9fafb;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .recommendation-card:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .recommendation-card.selected {
            border-color: #667eea;
            background: #eef2ff;
        }

        .recommendation-card.unavailable {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recommendation-card.unavailable:hover {
            border-color: #e2e8f0;
            box-shadow: none;
        }

        .recommendation-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox {
            width: 20px;
            height: 20px;
            accent-color: #667eea;
        }

        .recommendation-title {
            font-weight: 600;
            font-size: 1.1em;
            color: #1a202c;
        }

        .recommendation-desc {
            color: #718096;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .recommendation-data {
            font-size: 0.85em;
            color: #48bb78;
            font-weight: 500;
        }

        .recommendation-estimate {
            font-size: 0.8em;
            color: #667eea;
            font-style: italic;
        }

        .insights-container {
            display: none;
            padding: 30px;
        }

        .insight-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .insight-type {
            font-size: 0.8em;
            opacity: 0.8;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .insight-text {
            font-size: 1.1em;
            line-height: 1.5;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .collapse-btn {
            background: #cbd5e0;
            color: #2d3748;
            padding: 8px 16px;
            font-size: 0.9em;
        }

        .collapse-btn:hover {
            background: #a0aec0;
        }

        /* Data Table Styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .data-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .data-table th {
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .data-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
            color: #2d3748;
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        .data-table tbody tr:hover {
            background: #f7fafc;
        }

        .data-table tbody tr:nth-child(even) {
            background: #f8f9fa;
        }

        .data-table tbody tr:nth-child(even):hover {
            background: #f0f2f5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Reddit Analyzer</h1>
            <p>3-Step Interactive Analysis - Extract ‚Üí Recommend ‚Üí Analyze</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <input type="text" id="redditUrl" placeholder="Paste Reddit post URL here..." value="https://www.reddit.com/r/AskReddit/comments/1hqxo9o/what_industry_is_quietly_booming_right_now_but/">
                <button class="btn" onclick="startAnalysis()">Step 1: Extract Content</button>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p id="loadingMessage">Extracting valuable content...</p>
        </div>

        <!-- STEP 1: Extracted Content -->
        <div class="step-container" id="step1Container">
            <div class="step-header">
                <div class="step-number">1</div>
                <div class="step-title">Valuable Content Extracted</div>
            </div>

            <div class="stats-grid" id="extractionStats"></div>

            <div class="comment-list" id="commentList"></div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="proceedToStep2()">Step 2: Analyze & Recommend ‚Üí</button>
                <button class="btn" onclick="exportToPDF()" style="background: #ed8936;">üìÑ Export as PDF</button>
                <button class="btn" onclick="downloadForClaude(event)" style="background: #48bb78;">üíæ Download for Claude</button>
                <button class="btn" onclick="copyForClaude(event)" style="background: #9f7aea;">üìã Copy for Claude</button>
                <button class="btn collapse-btn" onclick="collapseStep('step1Container')">Collapse</button>
            </div>
        </div>

        <!-- STEP 2: Recommendations -->
        <div class="step-container" id="step2Container">
            <div class="step-header">
                <div class="step-number">2</div>
                <div class="step-title">Available Analyses</div>
            </div>

            <p style="margin-bottom: 20px; color: #718096;">
                Based on the extracted content, here are the analyses we can run. Select which insights you want to generate:
            </p>

            <div class="recommendations-grid" id="recommendationsGrid"></div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="proceedToStep3()" id="generateBtn" disabled>
                    Step 3: Generate Selected Insights ‚Üí
                </button>
                <button class="btn collapse-btn" onclick="collapseStep('step2Container')">Collapse</button>
            </div>
        </div>

        <!-- STEP 3: Insights -->
        <div class="insights-container" id="insightsContainer">
            <div class="step-header">
                <div class="step-number">3</div>
                <div class="step-title">Strategic Insights</div>
            </div>

            <div id="insightsList"></div>

            <div class="action-buttons">
                <button class="btn" onclick="startNewAnalysis()">Analyze Another Post</button>
            </div>
        </div>
    </div>

    <script>
        // Google Apps Script web app URL
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwLPQgHXv8RFFYDQS_eoEMoTOQp8gptNIUi9wJgvC-wK9WQI5XHn8yAVaH95WZR9WsP/exec';

        let extractedData = null;
        let selectedAnalyses = new Set();

        function startAnalysis() {
            const url = document.getElementById('redditUrl').value.trim();
            if (!url) {
                alert('Please enter a Reddit URL');
                return;
            }

            // Reset
            document.getElementById('step1Container').style.display = 'none';
            document.getElementById('step2Container').style.display = 'none';
            document.getElementById('insightsContainer').style.display = 'none';
            extractedData = null;
            selectedAnalyses.clear();

            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loadingMessage').textContent = 'Extracting valuable content from comments...';

            // Call Step 1: Extract
            const callbackName = 'callback_' + Date.now();
            window[callbackName] = function(response) {
                document.getElementById('loading').style.display = 'none';

                if (response.success) {
                    extractedData = response.data;
                    displayStep1(response.data);
                } else {
                    alert('Error: ' + (response.error || 'Unknown error'));
                }

                delete window[callbackName];
            };

            const scriptElement = document.createElement('script');
            scriptElement.src = `${SCRIPT_URL}?url=${encodeURIComponent(url)}&mode=step1_extract&callback=${callbackName}`;
            document.body.appendChild(scriptElement);
        }

        function displayStep1(data) {
            const container = document.getElementById('step1Container');
            container.style.display = 'block';

            // Display post title
            const postTitle = document.createElement('div');
            postTitle.style.cssText = 'background: #eef2ff; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #667eea;';
            postTitle.innerHTML = `
                <div style="font-size: 1.2em; font-weight: 600; color: #1a202c; margin-bottom: 10px;">
                    üìÑ ${escapeHtml(data.post.title)}
                </div>
                <div style="font-size: 0.9em; color: #718096;">
                    Posted by u/${escapeHtml(data.post.author)} ‚Ä¢ ${data.post.score} upvotes ‚Ä¢ ${data.post.num_comments} comments
                </div>
            `;
            document.getElementById('step1Container').insertBefore(postTitle, document.getElementById('extractionStats'));

            // Display stats
            const stats = data.extractionStats;
            document.getElementById('extractionStats').innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${stats.total}</div>
                    <div class="stat-label">Total Comments</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.extracted}</div>
                    <div class="stat-label">High-Value Extracted</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.percentageKept}%</div>
                    <div class="stat-label">Kept</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.averageScore}</div>
                    <div class="stat-label">Avg Score</div>
                </div>
            `;

            // Display comments
            const commentList = document.getElementById('commentList');
            commentList.innerHTML = data.valuableComments.map(comment => `
                <div class="comment-card">
                    <div class="comment-meta">
                        <span class="comment-author">üë§ u/${escapeHtml(comment.author)}</span>
                        <span class="comment-score">‚¨ÜÔ∏è ${comment.score}</span>
                        ${comment.awards > 0 ? `<span>üèÜ ${comment.awards}</span>` : ''}
                    </div>
                    <div class="comment-body">${escapeHtml(comment.body.substring(0, 400))}${comment.body.length > 400 ? '...' : ''}</div>
                </div>
            `).join('');

            // Scroll to step 1
            container.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function proceedToStep2() {
            if (!extractedData) return;

            // Run analysis in the browser - no backend call needed!
            const recommendations = analyzeAndRecommendInBrowser(extractedData);
            displayStep2(recommendations);
        }

        function analyzeAndRecommendInBrowser(contentData) {
            const comments = contentData.valuableComments || [];
            const recommendations = [];

            // 1. Entity & Topic Analysis
            const entities = {};
            comments.forEach(c => {
                const matches = (c.body || '').match(/\b[A-Z][A-Za-z]+(?:\s+[A-Z][A-Za-z]+){0,3}\b/g) || [];
                matches.forEach(e => {
                    if (e.length > 3) entities[e] = (entities[e] || 0) + 1;
                });
            });
            const topEntities = Object.entries(entities).filter(([_, count]) => count >= 3).length;
            if (topEntities > 0) {
                recommendations.push({
                    id: 'entity_analysis',
                    name: 'Entity & Topic Analysis',
                    description: 'Identify most discussed industries, products, or topics with sentiment',
                    available: true,
                    dataFound: `${topEntities} entities mentioned 3+ times`,
                    estimatedInsights: Math.min(topEntities, 10)
                });
            }

            // 2. Success/Failure Rate Analysis
            const successCount = comments.filter(c => /\b(worked|success|helped|fixed|cured|solved|great|amazing)\b/i.test(c.body)).length;
            const failureCount = comments.filter(c => /\b(failed|didn't work|worse|useless|no help|terrible|awful)\b/i.test(c.body)).length;
            if (successCount + failureCount >= 10) {
                recommendations.push({
                    id: 'outcome_analysis',
                    name: 'Success/Failure Rate Analysis',
                    description: 'Calculate success rates and effectiveness',
                    available: true,
                    dataFound: `${successCount} success + ${failureCount} failure mentions`,
                    estimatedInsights: 3
                });
            }

            // 3. Expert vs Experience Mix
            const expertCount = comments.filter(c => /\b(I work|professional|doctor|engineer|specialist|expert)\b/i.test(c.body)).length;
            const experienceCount = comments.filter(c => /\b(I |my |me |I've|I'm|personally)\b/i.test(c.body)).length;
            if (expertCount >= 5 || experienceCount >= 20) {
                recommendations.push({
                    id: 'speaker_analysis',
                    name: 'Expert vs Personal Experience Mix',
                    description: 'Balance between professional advice and lived experiences',
                    available: true,
                    dataFound: `${expertCount} expert comments, ${experienceCount} personal experiences`,
                    estimatedInsights: 2
                });
            }

            // 4. Pricing/Cost Analysis
            const priceCount = comments.filter(c => /\$[\d,]+|\bcost\b|\bprice\b|\bexpensive\b|\bcheap\b|\baffordable\b/i.test(c.body)).length;
            if (priceCount >= 10) {
                recommendations.push({
                    id: 'pricing_analysis',
                    name: 'Pricing & Cost Analysis',
                    description: 'Price sensitivity and value perception',
                    available: true,
                    dataFound: `${priceCount} comments mention pricing/cost`,
                    estimatedInsights: 3
                });
            }

            // 5. Timeline Expectations
            const timeCount = comments.filter(c => /\b(immediate|instant|days?|weeks?|months?|years?|long.?term|short.?term)\b/i.test(c.body)).length;
            if (timeCount >= 10) {
                recommendations.push({
                    id: 'timeline_analysis',
                    name: 'Timeline Expectations',
                    description: 'How long things take based on community experiences',
                    available: true,
                    dataFound: `${timeCount} comments mention timeframes`,
                    estimatedInsights: 2
                });
            }

            // 6. Consensus vs Controversy
            const agreeCount = comments.filter(c => /\b(agree|exactly|this|same|correct|absolutely)\b/i.test(c.body)).length;
            const disagreeCount = comments.filter(c => /\b(disagree|wrong|false|actually|but |however)\b/i.test(c.body)).length;
            if (agreeCount + disagreeCount >= 15) {
                const controversyRatio = disagreeCount / (agreeCount + disagreeCount);
                recommendations.push({
                    id: 'consensus_analysis',
                    name: controversyRatio > 0.4 ? 'Controversy Analysis' : 'Consensus Patterns',
                    description: controversyRatio > 0.4 ? 'Divisive topic with conflicting viewpoints' : 'Community alignment and agreement patterns',
                    available: true,
                    dataFound: `${Math.round(controversyRatio * 100)}% disagreement rate`,
                    estimatedInsights: 3
                });
            }

            // 7. Question/Answer Patterns
            const questionCount = comments.filter(c => /\?/.test(c.body)).length;
            const answerIndicators = comments.filter(c => /\b(here's|this is|you should|try|check out|look at)\b/i.test(c.body)).length;
            if (questionCount >= 5 && answerIndicators >= 5) {
                recommendations.push({
                    id: 'qa_analysis',
                    name: 'Question/Answer Dynamics',
                    description: 'Problem-solving and knowledge-sharing patterns',
                    available: true,
                    dataFound: `${questionCount} questions, ${answerIndicators} solution-oriented responses`,
                    estimatedInsights: 2
                });
            }

            // 8. Evidence & Source Quality
            const sourcedCount = comments.filter(c => /\b(source|study|research|according to|data shows)\b/i.test(c.body) || /https?:\/\//.test(c.body)).length;
            const anecdotalCount = comments.filter(c => /\b(in my experience|I think|I feel|personally|IMO|IMHO)\b/i.test(c.body)).length;
            if (sourcedCount + anecdotalCount >= 15) {
                const evidenceRatio = sourcedCount / (sourcedCount + anecdotalCount);
                recommendations.push({
                    id: 'evidence_analysis',
                    name: 'Evidence Quality Analysis',
                    description: 'Evidence-based vs opinion-based discussion balance',
                    available: true,
                    dataFound: `${Math.round(evidenceRatio * 100)}% sourced/evidence-based`,
                    estimatedInsights: 2
                });
            }

            // 9. Comparison Patterns (X vs Y)
            const comparisonCount = comments.filter(c => /\b(vs|versus|compared to|better than|worse than|instead of)\b/i.test(c.body)).length;
            if (comparisonCount >= 8) {
                recommendations.push({
                    id: 'comparison_analysis',
                    name: 'Comparison & Decision Analysis',
                    description: 'What people compare and evaluation criteria',
                    available: true,
                    dataFound: `${comparisonCount} comparison statements`,
                    estimatedInsights: 3
                });
            }

            // 10. Emotional Tone
            const positiveCount = comments.filter(c => /\b(love|excited|happy|grateful|amazing|fantastic|incredible)\b/i.test(c.body)).length;
            const negativeCount = comments.filter(c => /\b(hate|angry|frustrated|disappointed|terrible|awful|horrible)\b/i.test(c.body)).length;
            const neutralCount = comments.length - positiveCount - negativeCount;
            if (positiveCount + negativeCount >= 15) {
                const sentiment = positiveCount > negativeCount * 1.5 ? 'Positive' : negativeCount > positiveCount * 1.5 ? 'Negative' : 'Mixed';
                recommendations.push({
                    id: 'emotion_analysis',
                    name: `Emotional Tone: ${sentiment}`,
                    description: 'Community emotional response and sentiment',
                    available: true,
                    dataFound: `${positiveCount} positive, ${negativeCount} negative, ${neutralCount} neutral`,
                    estimatedInsights: 2
                });
            }

            return {
                totalRecommendations: recommendations.length,
                availableAnalyses: recommendations.length,
                recommendations: recommendations
            };
        }

        function displayStep2(data) {
            const container = document.getElementById('step2Container');
            container.style.display = 'block';

            const grid = document.getElementById('recommendationsGrid');
            grid.innerHTML = data.recommendations.map(rec => `
                <div class="recommendation-card ${rec.available ? '' : 'unavailable'}"
                     onclick="${rec.available ? `toggleAnalysis('${rec.id}')` : ''}"
                     id="rec_${rec.id}">
                    <div class="recommendation-header">
                        ${rec.available ? `<input type="checkbox" class="checkbox" id="check_${rec.id}" onchange="updateSelection()">` : ''}
                        <div class="recommendation-title">${rec.available ? '‚úì' : '‚úó'} ${escapeHtml(rec.name)}</div>
                    </div>
                    <div class="recommendation-desc">${escapeHtml(rec.description)}</div>
                    <div class="recommendation-data">üìä ${escapeHtml(rec.dataFound)}</div>
                    ${rec.available ? `<div class="recommendation-estimate">~${rec.estimatedInsights} insights expected</div>` : ''}
                </div>
            `).join('');

            // Scroll to step 2
            container.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function toggleAnalysis(analysisId) {
            const checkbox = document.getElementById('check_' + analysisId);
            const card = document.getElementById('rec_' + analysisId);

            if (checkbox.checked) {
                selectedAnalyses.delete(analysisId);
                checkbox.checked = false;
                card.classList.remove('selected');
            } else {
                selectedAnalyses.add(analysisId);
                checkbox.checked = true;
                card.classList.add('selected');
            }

            updateSelection();
        }

        function updateSelection() {
            const btn = document.getElementById('generateBtn');
            btn.disabled = selectedAnalyses.size === 0;
            btn.textContent = `Step 3: Generate ${selectedAnalyses.size} Selected Insight${selectedAnalyses.size !== 1 ? 's' : ''} ‚Üí`;
        }

        function proceedToStep3() {
            if (selectedAnalyses.size === 0 || !extractedData) return;

            // Run insights generation in the browser - no backend call!
            const insights = generateInsightsInBrowser(extractedData, Array.from(selectedAnalyses));
            displayStep3({insights: insights, totalInsights: insights.length, selectedAnalyses: Array.from(selectedAnalyses)});
        }

        function generateInsightsInBrowser(contentData, selectedAnalyses) {
            const comments = contentData.valuableComments || [];
            const insights = [];

            // Stopwords for entity extraction
            const stopwords = new Set(['The', 'This', 'That', 'These', 'Those', 'They', 'There', 'What', 'When', 'Where', 'Every', 'Each', 'Some', 'Many', 'More', 'Most', 'From', 'With', 'Reddit', 'Edit', 'Update', 'People', 'Data']);

            selectedAnalyses.forEach(analysisId => {
                if (analysisId === 'entity_analysis') {
                    // Entity & Topic Analysis
                    const entities = {};
                    const basePosWords = ['good', 'great', 'love', 'best', 'worked', 'helped', 'success', 'amazing', 'booming', 'growing'];
                    const baseNegWords = ['bad', 'terrible', 'hate', 'worst', 'failed', 'useless', 'awful', 'dying', 'declining'];

                    comments.forEach(c => {
                        const body = c.body || '';
                        const matches = body.match(/\b[A-Z][A-Za-z]+(?:\s+[A-Z][A-Za-z]+){0,3}\b/g) || [];
                        matches.forEach(entity => {
                            if (entity.length > 3 && !stopwords.has(entity)) {
                                if (!entities[entity]) entities[entity] = {count: 0, pos: 0, neg: 0, neu: 0};
                                entities[entity].count++;

                                const idx = body.indexOf(entity);
                                const context = body.substring(Math.max(0, idx - 60), Math.min(body.length, idx + entity.length + 60)).toLowerCase();
                                if (basePosWords.some(w => context.includes(w))) entities[entity].pos++;
                                else if (baseNegWords.some(w => context.includes(w))) entities[entity].neg++;
                                else entities[entity].neu++;
                            }
                        });
                    });

                    const topEntities = Object.entries(entities)
                        .filter(([_, data]) => data.count >= 3)
                        .sort((a, b) => b[1].count - a[1].count)
                        .slice(0, 10);

                    topEntities.forEach(([entity, data]) => {
                        const total = data.pos + data.neg + data.neu;
                        const sentiment = total > 0 ? Math.round((data.pos / total) * 100) : 0;
                        const percentage = Math.round((data.count / comments.length) * 100);

                        let sentimentText = '';
                        if (sentiment >= 70) sentimentText = ` with ${sentiment}% positive sentiment - highly favored`;
                        else if (sentiment <= 30 && sentiment > 0) sentimentText = ` with only ${sentiment}% positive sentiment - concerns noted`;

                        insights.push({
                            type: 'entity_analysis',
                            insight: `"${entity}" discussed in ${percentage}% of comments (${data.count} mentions)${sentimentText}`
                        });
                    });
                }

                if (analysisId === 'outcome_analysis') {
                    const worked = comments.filter(c => /\b(worked|success|helped|fixed|cured|solved)\b/i.test(c.body)).length;
                    const failed = comments.filter(c => /\b(failed|didn't work|worse|useless|no help)\b/i.test(c.body)).length;
                    const total = worked + failed;

                    if (total >= 10) {
                        const successRate = Math.round((worked / total) * 100);
                        let interpretation = successRate >= 70 ? 'highly effective' : successRate >= 50 ? 'moderately effective' : successRate >= 30 ? 'mixed results' : 'low success rate';

                        insights.push({
                            type: 'outcome_analysis',
                            insight: `${successRate}% success rate across reported attempts (${worked} worked vs ${failed} failed) - ${interpretation}`
                        });
                    }
                }

                if (analysisId === 'speaker_analysis') {
                    const expertCount = comments.filter(c => /\b(I work|professional|doctor|engineer|specialist|expert)\b/i.test(c.body)).length;
                    const experienceCount = comments.filter(c => /\b(I |my |me |I've|I'm|personally)\b/i.test(c.body)).length;
                    const expertPct = Math.round((expertCount / comments.length) * 100);
                    const experiencePct = Math.round((experienceCount / comments.length) * 100);

                    let insight = expertPct >= 20 ?
                        `${expertPct}% expert/professional input, ${experiencePct}% firsthand experiences - balanced perspectives` :
                        `${experiencePct}% firsthand personal experiences - highly authentic discussion`;

                    insights.push({type: 'speaker_analysis', insight: insight});
                }

                if (analysisId === 'pricing_analysis') {
                    const priceComments = comments.filter(c => /\$[\d,]+|\bcost\b|\bprice\b|\bexpensive\b|\bcheap\b|\baffordable\b/i.test(c.body));
                    const expensiveMentions = priceComments.filter(c => /\bexpensive\b|\bpricey\b|\bcost\b|\$[\d,]{3,}/i.test(c.body)).length;
                    const cheapMentions = priceComments.filter(c => /\bcheap\b|\baffordable\b|\bbudget\b/i.test(c.body)).length;
                    const pricePct = Math.round((priceComments.length / comments.length) * 100);

                    insights.push({
                        type: 'pricing_analysis',
                        insight: `Price discussed in ${pricePct}% of comments - ${expensiveMentions > cheapMentions ? 'Quality over price' : 'Budget-conscious'} audience`
                    });
                }

                if (analysisId === 'timeline_analysis') {
                    const timeMentions = {};
                    const timePatterns = {
                        'immediate': /\b(immediately|instant|right away|same day)\b/i,
                        'days': /\b(days?|few days|couple days)\b/i,
                        'weeks': /\b(weeks?|few weeks)\b/i,
                        'months': /\b(months?|several months)\b/i,
                        'years': /\b(years?|long time|forever)\b/i
                    };

                    comments.forEach(c => {
                        Object.entries(timePatterns).forEach(([timeline, pattern]) => {
                            if (pattern.test(c.body)) timeMentions[timeline] = (timeMentions[timeline] || 0) + 1;
                        });
                    });

                    const dominant = Object.entries(timeMentions).sort((a, b) => b[1] - a[1])[0];
                    if (dominant && dominant[1] >= 3) {
                        const pct = Math.round((dominant[1] / comments.length) * 100);
                        insights.push({
                            type: 'timeline_analysis',
                            insight: `Most common timeline: "${dominant[0]}" (${pct}% of comments) - sets realistic expectations`
                        });
                    }
                }

                if (analysisId === 'consensus_analysis') {
                    const agreeCount = comments.filter(c => /\b(agree|exactly|this|same|correct|absolutely)\b/i.test(c.body)).length;
                    const disagreeCount = comments.filter(c => /\b(disagree|wrong|false|actually|but |however)\b/i.test(c.body)).length;
                    const controversyRatio = disagreeCount / (agreeCount + disagreeCount);
                    const controversyPct = Math.round(controversyRatio * 100);

                    if (controversyRatio > 0.4) {
                        insights.push({
                            type: 'consensus_analysis',
                            insight: `${controversyPct}% disagreement rate - Divisive topic with multiple conflicting viewpoints`
                        });
                        insights.push({
                            type: 'consensus_analysis',
                            insight: `Community split between perspectives - Deeper research needed to understand nuances`
                        });
                    } else {
                        insights.push({
                            type: 'consensus_analysis',
                            insight: `${100 - controversyPct}% consensus rate - Strong community agreement on key points`
                        });
                        insights.push({
                            type: 'consensus_analysis',
                            insight: `Unified perspective signals reliable information - Lower risk of misinformation`
                        });
                    }
                }

                if (analysisId === 'qa_analysis') {
                    const questionCount = comments.filter(c => /\?/.test(c.body)).length;
                    const answerCount = comments.filter(c => /\b(here's|this is|you should|try|check out|look at)\b/i.test(c.body)).length;
                    const qaRatio = answerCount / questionCount;

                    insights.push({
                        type: 'qa_analysis',
                        insight: `${questionCount} questions, ${answerCount} solution-oriented responses (${qaRatio.toFixed(1)}:1 ratio)`
                    });

                    if (qaRatio > 1.5) {
                        insights.push({
                            type: 'qa_analysis',
                            insight: `High answer-to-question ratio indicates helpful, solution-focused community`
                        });
                    } else {
                        insights.push({
                            type: 'qa_analysis',
                            insight: `Many unanswered questions - indicates emerging topic or knowledge gaps`
                        });
                    }
                }

                if (analysisId === 'evidence_analysis') {
                    const sourcedCount = comments.filter(c => /\b(source|study|research|according to|data shows)\b/i.test(c.body) || /https?:\/\//.test(c.body)).length;
                    const anecdotalCount = comments.filter(c => /\b(in my experience|I think|I feel|personally|IMO|IMHO)\b/i.test(c.body)).length;
                    const evidenceRatio = sourcedCount / (sourcedCount + anecdotalCount);
                    const evidencePct = Math.round(evidenceRatio * 100);

                    insights.push({
                        type: 'evidence_analysis',
                        insight: `${evidencePct}% evidence-based, ${100 - evidencePct}% opinion-based - ${evidencePct > 60 ? 'High credibility' : evidencePct > 40 ? 'Mixed credibility' : 'Mostly anecdotal'}`
                    });

                    if (evidencePct > 50) {
                        insights.push({
                            type: 'evidence_analysis',
                            insight: `Strong sourcing indicates trustworthy information - Can be cited with confidence`
                        });
                    } else {
                        insights.push({
                            type: 'evidence_analysis',
                            insight: `Opinion-heavy discussion - Verify claims independently before relying on them`
                        });
                    }
                }

                if (analysisId === 'comparison_analysis') {
                    const comparisons = [];
                    comments.forEach(c => {
                        const matches = (c.body || '').match(/([A-Za-z\s]+)\s+(vs|versus|compared to|better than|worse than|instead of)\s+([A-Za-z\s]+)/gi);
                        if (matches) matches.forEach(m => comparisons.push(m));
                    });

                    insights.push({
                        type: 'comparison_analysis',
                        insight: `${comparisons.length} comparison statements found - Active evaluation and decision-making`
                    });

                    if (comparisons.length > 0) {
                        const examples = comparisons.slice(0, 3).join(', ');
                        insights.push({
                            type: 'comparison_analysis',
                            insight: `Sample comparisons: ${examples.substring(0, 150)}...`
                        });
                    }

                    insights.push({
                        type: 'comparison_analysis',
                        insight: `Comparison-rich discussions indicate buyers/decision-makers seeking optimal choices`
                    });
                }

                if (analysisId === 'emotion_analysis') {
                    const positiveCount = comments.filter(c => /\b(love|excited|happy|grateful|amazing|fantastic|incredible)\b/i.test(c.body)).length;
                    const negativeCount = comments.filter(c => /\b(hate|angry|frustrated|disappointed|terrible|awful|horrible)\b/i.test(c.body)).length;
                    const neutralCount = comments.length - positiveCount - negativeCount;

                    const posPct = Math.round((positiveCount / comments.length) * 100);
                    const negPct = Math.round((negativeCount / comments.length) * 100);
                    const neuPct = Math.round((neutralCount / comments.length) * 100);

                    insights.push({
                        type: 'emotion_analysis',
                        insight: `Emotional breakdown: ${posPct}% positive, ${negPct}% negative, ${neuPct}% neutral`
                    });

                    if (posPct > negPct * 2) {
                        insights.push({
                            type: 'emotion_analysis',
                            insight: `Overwhelmingly positive tone - Strong community satisfaction and enthusiasm`
                        });
                    } else if (negPct > posPct * 2) {
                        insights.push({
                            type: 'emotion_analysis',
                            insight: `Predominantly negative tone - Significant frustration or disappointment present`
                        });
                    } else {
                        insights.push({
                            type: 'emotion_analysis',
                            insight: `Balanced emotional tone - Mature, objective discussion`
                        });
                    }
                }
            });

            return insights;
        }

        // ========================================================================
        // GENERATE DATA TABLES (for UI display)
        // ========================================================================

        function generateDataTables(data) {
            const comments = extractedData.valuableComments || [];
            const tables = [];

            // UNIVERSAL TABLE 1: Upvote Performance Tiers
            const tiers = [
                {name: 'Viral', min: 5000, comments: []},
                {name: 'High', min: 1000, max: 4999, comments: []},
                {name: 'Medium', min: 100, max: 999, comments: []},
                {name: 'Low', min: 0, max: 99, comments: []}
            ];

            comments.forEach((c, idx) => {
                const score = c.score || 0;
                if (score >= 5000) tiers[0].comments.push({...c, pos: idx + 1});
                else if (score >= 1000) tiers[1].comments.push({...c, pos: idx + 1});
                else if (score >= 100) tiers[2].comments.push({...c, pos: idx + 1});
                else tiers[3].comments.push({...c, pos: idx + 1});
            });

            const tierTableRows = tiers
                .filter(t => t.comments.length > 0)
                .map(t => {
                    const avgPos = Math.round(t.comments.reduce((sum, c) => sum + c.pos, 0) / t.comments.length);
                    const range = t.min === 5000 ? `${t.min}+` : `${t.min}-${t.max}`;
                    return `<tr>
                        <td><strong>${t.name}</strong></td>
                        <td>${range}</td>
                        <td>${t.comments.length}</td>
                        <td>#${avgPos}</td>
                    </tr>`;
                }).join('');

            if (tierTableRows) {
                tables.push({
                    title: 'üìä Upvote Performance Tiers',
                    html: `<table class="data-table">
                        <thead>
                            <tr><th>Tier</th><th>Range</th><th># Comments</th><th>Avg Position</th></tr>
                        </thead>
                        <tbody>${tierTableRows}</tbody>
                    </table>`
                });
            }

            // UNIVERSAL TABLE 2: Top 10 Comments Breakdown
            const top10 = comments.slice(0, Math.min(10, comments.length));
            if (top10.length > 0) {
                const top10Rows = top10.map((c, idx) => `<tr>
                    <td>${idx + 1}</td>
                    <td>u/${escapeHtml(c.author)}</td>
                    <td>${c.score}</td>
                    <td>${c.body.length} chars</td>
                    <td>${c.awards || 0}</td>
                </tr>`).join('');

                tables.push({
                    title: 'üèÜ Top 10 Comments Performance',
                    html: `<table class="data-table">
                        <thead>
                            <tr><th>Rank</th><th>Author</th><th>Upvotes</th><th>Length</th><th>Awards</th></tr>
                        </thead>
                        <tbody>${top10Rows}</tbody>
                    </table>`
                });
            }

            // UNIVERSAL TABLE 3: Word Count vs Engagement
            const wordCountBuckets = [
                {range: '1-50', min: 1, max: 50, comments: []},
                {range: '51-150', min: 51, max: 150, comments: []},
                {range: '151-300', min: 151, max: 300, comments: []},
                {range: '300+', min: 301, max: 999999, comments: []}
            ];

            comments.forEach(c => {
                const wordCount = (c.body || '').split(/\s+/).length;
                const bucket = wordCountBuckets.find(b => wordCount >= b.min && wordCount <= b.max);
                if (bucket) bucket.comments.push(c);
            });

            const wordCountRows = wordCountBuckets
                .filter(b => b.comments.length > 0)
                .map(b => {
                    const avgUpvotes = Math.round(b.comments.reduce((sum, c) => sum + (c.score || 0), 0) / b.comments.length);
                    const optimal = avgUpvotes === Math.max(...wordCountBuckets.map(x => x.comments.length > 0 ? Math.round(x.comments.reduce((s, c) => s + (c.score || 0), 0) / x.comments.length) : 0)) ? '‚úì' : '';
                    return `<tr>
                        <td>${b.range} words</td>
                        <td>${b.comments.length}</td>
                        <td>${avgUpvotes}</td>
                        <td>${optimal}</td>
                    </tr>`;
                }).join('');

            if (wordCountRows) {
                tables.push({
                    title: 'üìù Word Count vs Engagement',
                    html: `<table class="data-table">
                        <thead>
                            <tr><th>Range</th><th># Comments</th><th>Avg Upvotes</th><th>Optimal</th></tr>
                        </thead>
                        <tbody>${wordCountRows}</tbody>
                    </table>`
                });
            }

            // UNIVERSAL TABLE 4: Sentiment Distribution (if emotion analysis was selected)
            if (data.selectedAnalyses.includes('emotion_analysis')) {
                const positive = comments.filter(c => /\b(love|excited|happy|grateful|amazing|fantastic|incredible)\b/i.test(c.body));
                const negative = comments.filter(c => /\b(hate|angry|frustrated|disappointed|terrible|awful|horrible)\b/i.test(c.body));
                const neutral = comments.length - positive.length - negative.length;

                const avgPosUpvotes = positive.length > 0 ? Math.round(positive.reduce((s, c) => s + (c.score || 0), 0) / positive.length) : 0;
                const avgNegUpvotes = negative.length > 0 ? Math.round(negative.reduce((s, c) => s + (c.score || 0), 0) / negative.length) : 0;
                const avgNeuUpvotes = neutral > 0 ? Math.round(comments.filter(c => !positive.includes(c) && !negative.includes(c)).reduce((s, c) => s + (c.score || 0), 0) / neutral) : 0;

                tables.push({
                    title: 'üòä Sentiment Distribution',
                    html: `<table class="data-table">
                        <thead>
                            <tr><th>Sentiment</th><th># Comments</th><th>% of Total</th><th>Avg Upvotes</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>üòä Positive</td><td>${positive.length}</td><td>${Math.round(positive.length/comments.length*100)}%</td><td>${avgPosUpvotes}</td></tr>
                            <tr><td>üò† Negative</td><td>${negative.length}</td><td>${Math.round(negative.length/comments.length*100)}%</td><td>${avgNegUpvotes}</td></tr>
                            <tr><td>üòê Neutral</td><td>${neutral}</td><td>${Math.round(neutral/comments.length*100)}%</td><td>${avgNeuUpvotes}</td></tr>
                        </tbody>
                    </table>`
                });
            }

            // Content-specific table: Success Rates (if outcome_analysis selected)
            if (data.selectedAnalyses.includes('outcome_analysis')) {
                const worked = comments.filter(c => /\b(worked|success|helped|fixed|cured|solved)\b/i.test(c.body));
                const failed = comments.filter(c => /\b(failed|didn't work|worse|useless|no help)\b/i.test(c.body));

                if (worked.length + failed.length >= 5) {
                    const successRate = Math.round((worked.length / (worked.length + failed.length)) * 100);
                    tables.push({
                        title: '‚úÖ Success vs Failure Breakdown',
                        html: `<table class="data-table">
                            <thead>
                                <tr><th>Outcome</th><th># Comments</th><th>% of Total</th><th>Success Rate</th></tr>
                            </thead>
                            <tbody>
                                <tr><td>‚úÖ Worked</td><td>${worked.length}</td><td>${Math.round(worked.length/comments.length*100)}%</td><td rowspan="2" style="font-size: 1.3em; font-weight: bold; vertical-align: middle;">${successRate}%</td></tr>
                                <tr><td>‚ùå Failed</td><td>${failed.length}</td><td>${Math.round(failed.length/comments.length*100)}%</td></tr>
                            </tbody>
                        </table>`
                    });
                }
            }

            return tables;
        }

        function displayStep3(data) {
            const container = document.getElementById('insightsContainer');
            container.style.display = 'block';

            // Generate tables
            const tables = generateDataTables(data);

            const list = document.getElementById('insightsList');

            let html = '';

            // Display data tables first
            if (tables.length > 0) {
                html += '<div style="margin-bottom: 30px;"><h3 style="color: #667eea; margin-bottom: 20px;">üìä Data Analysis</h3>';
                tables.forEach(table => {
                    html += `<div style="margin-bottom: 30px;">
                        <h4 style="color: #4a5568; margin-bottom: 15px;">${table.title}</h4>
                        ${table.html}
                    </div>`;
                });
                html += '</div>';
            }

            // Display insights
            html += '<h3 style="color: #667eea; margin-bottom: 20px;">üí° Key Insights</h3>';
            html += data.insights.map(insight => `
                <div class="insight-card">
                    <div class="insight-type">${escapeHtml(insight.type.replace(/_/g, ' '))}</div>
                    <div class="insight-text">üí° ${escapeHtml(insight.insight)}</div>
                </div>
            `).join('');

            if (data.insights.length === 0) {
                html = '<p style="text-align: center; color: #718096; padding: 40px;">No insights generated. Try selecting different analyses.</p>';
            }

            list.innerHTML = html;

            // Scroll to insights
            container.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function collapseStep(stepId) {
            document.getElementById(stepId).style.display = 'none';
        }

        function startNewAnalysis() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
            document.getElementById('redditUrl').value = '';
            document.getElementById('redditUrl').focus();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function exportToPDF() {
            if (!extractedData) {
                alert('No data to export');
                return;
            }

            // Create a new window for PDF export
            const printWindow = window.open('', '', 'width=800,height=600');

            const html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${escapeHtml(extractedData.post.title)}</title>
                    <style>
                        body {
                            font-family: Arial, sans-serif;
                            line-height: 1.6;
                            max-width: 800px;
                            margin: 20px;
                            color: #333;
                        }
                        .header {
                            border-bottom: 3px solid #667eea;
                            padding-bottom: 15px;
                            margin-bottom: 20px;
                        }
                        h1 {
                            color: #667eea;
                            font-size: 1.5em;
                            margin-bottom: 10px;
                        }
                        .meta {
                            color: #666;
                            font-size: 0.9em;
                            margin-bottom: 20px;
                        }
                        .stats {
                            background: #f5f5f5;
                            padding: 15px;
                            border-radius: 5px;
                            margin-bottom: 20px;
                        }
                        .stats-grid {
                            display: grid;
                            grid-template-columns: repeat(4, 1fr);
                            gap: 15px;
                        }
                        .stat {
                            text-align: center;
                        }
                        .stat-value {
                            font-size: 1.5em;
                            font-weight: bold;
                            color: #667eea;
                        }
                        .stat-label {
                            font-size: 0.85em;
                            color: #666;
                        }
                        .comment {
                            border-left: 3px solid #667eea;
                            padding: 15px;
                            margin-bottom: 15px;
                            background: #f9f9f9;
                            page-break-inside: avoid;
                        }
                        .comment-meta {
                            font-size: 0.9em;
                            color: #666;
                            margin-bottom: 8px;
                        }
                        .comment-author {
                            font-weight: bold;
                            color: #667eea;
                        }
                        .comment-score {
                            color: #48bb78;
                            margin-left: 10px;
                        }
                        .comment-body {
                            white-space: pre-wrap;
                            word-wrap: break-word;
                        }
                        .footer {
                            margin-top: 30px;
                            padding-top: 15px;
                            border-top: 1px solid #ddd;
                            text-align: center;
                            color: #999;
                            font-size: 0.85em;
                        }
                        @media print {
                            body { margin: 15px; }
                        }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>üìÑ ${escapeHtml(extractedData.post.title)}</h1>
                        <div class="meta">
                            Posted by u/${escapeHtml(extractedData.post.author)} ‚Ä¢
                            ${extractedData.post.score} upvotes ‚Ä¢
                            ${extractedData.post.num_comments} comments
                        </div>
                    </div>

                    <div class="stats">
                        <div class="stats-grid">
                            <div class="stat">
                                <div class="stat-value">${extractedData.extractionStats.total}</div>
                                <div class="stat-label">Total Comments</div>
                            </div>
                            <div class="stat">
                                <div class="stat-value">${extractedData.extractionStats.extracted}</div>
                                <div class="stat-label">High-Value Extracted</div>
                            </div>
                            <div class="stat">
                                <div class="stat-value">${extractedData.extractionStats.percentageKept}%</div>
                                <div class="stat-label">Kept</div>
                            </div>
                            <div class="stat">
                                <div class="stat-value">${extractedData.extractionStats.averageScore}</div>
                                <div class="stat-label">Avg Score</div>
                            </div>
                        </div>
                    </div>

                    <h2 style="color: #667eea; margin-bottom: 15px;">Valuable Comments (${extractedData.valuableComments.length})</h2>

                    ${extractedData.valuableComments.map((comment, index) => `
                        <div class="comment">
                            <div class="comment-meta">
                                <span class="comment-author">#${index + 1} ‚Ä¢ u/${escapeHtml(comment.author)}</span>
                                <span class="comment-score">‚¨ÜÔ∏è ${comment.score}</span>
                                ${comment.awards > 0 ? `<span>üèÜ ${comment.awards}</span>` : ''}
                            </div>
                            <div class="comment-body">${escapeHtml(comment.body)}</div>
                        </div>
                    `).join('')}

                    <div class="footer">
                        Generated by Reddit Analyzer ‚Ä¢ ${new Date().toLocaleString()}
                    </div>
                </body>
                </html>
            `;

            printWindow.document.write(html);
            printWindow.document.close();

            // Wait for content to load, then trigger print dialog
            setTimeout(() => {
                printWindow.print();
            }, 250);
        }

        // ========================================================================
        // FORMAT DATA FOR CLAUDE PRO (runs in browser - no backend call!)
        // ========================================================================

        function formatForClaudeAnalysis(data) {
            const post = data.post;
            const comments = data.valuableComments;
            const stats = data.extractionStats;

            // Build the formatted text with embedded prompt
            let output = `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
REDDIT CONTENT ANALYSIS REQUEST
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

You are an expert Reddit content analyst. Below is a Reddit post with extracted high-value comments. Provide deep, actionable insights that go beyond surface-level observations.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ANALYSIS FRAMEWORK
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

1. CONTENT INTELLIGENCE
   ‚Ä¢ What type of discussion is this? (Don't force categories - describe what you observe)
   ‚Ä¢ What makes this content engaging to this audience?
   ‚Ä¢ What patterns emerge that might not be immediately obvious?

2. ENGAGEMENT DYNAMICS
   ‚Ä¢ Why did certain comments get high upvotes? What resonated?
   ‚Ä¢ Is there consensus, controversy, or something else driving engagement?
   ‚Ä¢ What's the upvote distribution telling us?

3. HIDDEN PATTERNS
   Look for non-obvious patterns:
   ‚Ä¢ Cognitive biases (confirmation bias, survivorship bias, etc.)
   ‚Ä¢ Emotional triggers (fear, hope, identity, validation)
   ‚Ä¢ Social dynamics (expertise vs experience, contrarian vs conformist)
   ‚Ä¢ Temporal patterns (immediate vs long-term thinking)
   ‚Ä¢ Economic factors (price sensitivity, value perception)

4. AUDIENCE INSIGHTS
   ‚Ä¢ Who is participating? (experts, enthusiasts, beginners, skeptics)
   ‚Ä¢ What do they care about? (practical advice, validation, entertainment, learning)
   ‚Ä¢ What assumptions do they share?
   ‚Ä¢ What questions are they really asking (vs what they explicitly say)?

5. CONTENT STRATEGY INTELLIGENCE
   If someone wanted to create similar engaging content:
   ‚Ä¢ What elements should they replicate?
   ‚Ä¢ What format works best? (question, story, controversy, education)
   ‚Ä¢ What tone resonates?
   ‚Ä¢ What timing/context matters?

6. SURPRISING FINDINGS
   ‚Ä¢ What's unexpected or counter-intuitive?
   ‚Ä¢ What would most people miss on first read?
   ‚Ä¢ What does this reveal about the community/topic/culture?

7. ACTIONABLE RECOMMENDATIONS
   Provide 3-5 specific, actionable takeaways for:
   ‚Ä¢ Content creators (how to replicate engagement)
   ‚Ä¢ Marketers (audience insights for targeting)
   ‚Ä¢ Researchers (cultural/social patterns)
   ‚Ä¢ The original poster (what they can learn)

8. DATA ANALYSIS WITH TABLES
   Generate data-driven tables that are RELEVANT to this specific content type.
   Choose 5-8 tables from these options based on what makes sense for THIS discussion:

   UNIVERSAL TABLES (apply to most posts):
   ‚Ä¢ Upvote Performance Tiers (Tier | Range | # Comments | Avg Position | Patterns)
   ‚Ä¢ Top 10-20 Comments Breakdown (Rank | Author | Upvotes | Theme | Key Factor)
   ‚Ä¢ Theme Distribution & Engagement (Theme | # Comments | Avg Upvotes | % of Discussion)
   ‚Ä¢ Word Count vs Engagement (Range | # Comments | Avg Upvotes | Optimal?)
   ‚Ä¢ Sentiment Distribution (Sentiment | # Comments | Avg Upvotes | Characteristics)

   CONTENT-SPECIFIC TABLES (choose relevant ones):
   For FACTUAL/TIL: Cognitive violations, verifiability matrix, temporal references
   For PRODUCT/REVIEW: Feature sentiment, price analysis, comparison matrix
   For OPINION/DEBATE: Viewpoint distribution, argument quality, polarization
   For ADVICE/HOW-TO: Success rates, expert vs experience, timeline expectations
   For STORY/EXPERIENCE: Emotional responses, advice vs empathy ratios

   TABLE GENERATION RULES:
   ‚Ä¢ Use markdown table format for easy reading
   ‚Ä¢ Include column headers and clear data
   ‚Ä¢ Add brief interpretation after each table
   ‚Ä¢ Only include tables that have sufficient data (minimum 5-10 data points)
   ‚Ä¢ Prioritize tables that reveal non-obvious insights
   ‚Ä¢ Calculate percentages, averages, and ratios where meaningful

IMPORTANT ANALYSIS GUIDELINES:
‚Ä¢ Don't just summarize - analyze WHY things are the way they are
‚Ä¢ Look for patterns across multiple comments, not just individual standouts
‚Ä¢ Consider context: subreddit culture, current events, audience demographics
‚Ä¢ Be honest if something is unclear or if the data is too limited
‚Ä¢ Cite specific examples from the comments to support your insights
‚Ä¢ Generate tables in markdown format for clarity
‚Ä¢ Choose 5-8 most relevant tables based on content type - don't force irrelevant tables

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
POST DATA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

TITLE: ${post.title}

METADATA:
‚Ä¢ Posted by: u/${post.author}
‚Ä¢ Subreddit: r/${post.subreddit || 'unknown'}
‚Ä¢ Post Score: ${post.score} upvotes
‚Ä¢ Total Comments: ${post.num_comments}

EXTRACTION STATISTICS:
‚Ä¢ Total Comments Processed: ${stats.total}
‚Ä¢ High-Value Comments Extracted: ${stats.extracted} (${stats.percentageKept}% kept)
‚Ä¢ Average Comment Score: ${stats.averageScore}
‚Ä¢ Extraction Quality: ${stats.percentageKept}% retention indicates ${stats.percentageKept > 50 ? 'diverse quality' : 'highly selective filtering'}

POST BODY:
${post.selftext || '[No body text - link or image post]'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
HIGH-VALUE COMMENTS (${comments.length} comments)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

`;

            // Add all comments
            comments.forEach((comment, index) => {
                output += `
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
COMMENT #${index + 1}
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Author: u/${comment.author}
Score: ${comment.score} upvotes${comment.awards > 0 ? ` | Awards: ${comment.awards}` : ''}
Engagement Rank: #${index + 1} of ${comments.length}

${comment.body}
`;
            });

            output += `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
END OF DATA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Exported: ${new Date().toISOString()}
Analysis Tool: Reddit Analyzer v1.0

Now please provide your comprehensive analysis following the framework above.
`;

            return output;
        }

        // ========================================================================
        // DOWNLOAD FOR CLAUDE (no Drive permissions needed!)
        // ========================================================================

        function downloadForClaude(event) {
            if (!extractedData) {
                alert('No data to download. Please extract comments first.');
                return;
            }

            // Show loading state
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Formatting...';
            btn.disabled = true;

            // Format content in browser (no backend call!)
            try {
                const formattedText = formatForClaudeAnalysis(extractedData);

                // Create download
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const postTitle = extractedData.post.title.substring(0, 50).replace(/[^a-z0-9]/gi, '_');
                const fileName = `Reddit_Analysis_${postTitle}_${timestamp}.txt`;

                const blob = new Blob([formattedText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // Show success
                btn.innerHTML = '‚úÖ Downloaded!';
                btn.disabled = false;
                setTimeout(() => {
                    btn.innerHTML = originalText;
                }, 2000);

                showClaudeInstructions('download');
            } catch (error) {
                btn.innerHTML = originalText;
                btn.disabled = false;
                alert('‚ùå Failed to format content:\n\n' + error.message);
            }
        }

        // ========================================================================
        // COPY FOR CLAUDE (clipboard with embedded prompt)
        // ========================================================================

        function copyForClaude(event) {
            if (!extractedData) {
                alert('No data to copy. Please extract comments first.');
                return;
            }

            // Show loading state
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Formatting...';
            btn.disabled = true;

            // Format content in browser (no backend call!)
            try {
                const formattedText = formatForClaudeAnalysis(extractedData);

                // Copy to clipboard
                navigator.clipboard.writeText(formattedText)
                    .then(() => {
                        // Show success message
                        btn.innerHTML = '‚úÖ Copied!';
                        btn.disabled = false;
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                        }, 2000);

                        // Show instructions
                        showClaudeInstructions('copy');
                    })
                    .catch(err => {
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                        alert('‚ùå Failed to copy to clipboard:\n\n' + err);
                    });
            } catch (error) {
                btn.innerHTML = originalText;
                btn.disabled = false;
                alert('‚ùå Failed to format content:\n\n' + error.message);
            }
        }

        // ========================================================================
        // CLAUDE PRO INSTRUCTIONS
        // ========================================================================

        function showClaudeInstructions(mode = 'copy') {
            const instructions = mode === 'download' ? `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
HOW TO USE WITH CLAUDE PRO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STEP 1: Upload to Claude Pro
1. Go to claude.ai and start a new chat
2. Click the üìé attachment icon
3. Click "Upload from computer"
4. Select the file you just downloaded (in your Downloads folder)
5. Claude will automatically read the analysis prompt and provide insights!

ALTERNATIVE: Upload to Google Drive first
1. Upload the downloaded file to your Google Drive
2. In Claude Pro, click üìé ‚Üí "From Google Drive"
3. Select the uploaded file
4. Claude will analyze it automatically!

NOTE: The universal analysis prompt is already embedded in the file.
You don't need to write anything - Claude will automatically analyze it!

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
` : `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
HOW TO USE WITH CLAUDE PRO
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STEP 1: Paste into Claude Pro
1. Go to claude.ai and start a new chat
2. Paste (Ctrl+V / Cmd+V) the copied content
3. Press Enter
4. Claude will automatically read the analysis prompt and provide insights!

NOTE: The universal analysis prompt is already embedded in the copied text.
You don't need to write anything - Claude will automatically analyze it!

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
`;

            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 10px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            `;

            content.innerHTML = `
                <h2 style="color: #667eea; margin-bottom: 20px;">ü§ñ Use with Claude Pro</h2>
                <pre style="white-space: pre-wrap; font-family: monospace; font-size: 0.9em; line-height: 1.6; background: #f5f5f5; padding: 20px; border-radius: 5px; overflow-x: auto;">${escapeHtml(instructions)}</pre>
                <button onclick="this.closest('div').parentElement.remove()" style="background: #667eea; color: white; border: none; padding: 12px 24px; border-radius: 5px; cursor: pointer; font-size: 1em; margin-top: 20px; width: 100%;">Got it!</button>
            `;

            modal.appendChild(content);
            document.body.appendChild(modal);

            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
    </script>
</body>
</html>
